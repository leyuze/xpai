---
title: Apache POI教程
date: 2021-06-18 19:31:13
permalink: /pages/a04899/
categories:
  - 后端
  - Java框架篇
tags:
  - 
---
很多时候，一个软件应用程序需要生成Microsoft Excel文件格式的报告。有时，一个应用程序甚至希望将Excel文件作为输入数据。例如，一个公司开发的应用程序将财务部门需要所有输出生成自己的Excel。

任何Java程序员愿意将MS Office文件的输出，可以使用预定义和只读API来做到。

## **什么是Apache POI？**

Apache POI是一种流行的API，它允许程序员使用Java程序创建，修改和显示MS Office文件。这由Apache软件基金会开发使用Java分布式设计或修改Microsoft Office文件的开源库。它包含类和方法对用户输入数据或文件到MS Office文档进行解码。

## **Apache POI组件**

Apache POI包含类和方法，来将MS Office所有OLE 2文档复合。此API组件的列表如下。

- **POIFS (较差混淆技术实现文件系统) :** 此组件是所有其他POI元件的基本因素。它被用来明确地读取不同的文件。
- **HSSF (可怕的电子表格格式) :** 它被用来读取和写入MS-Excel文件的xls格式。
- **XSSF (XML格式) :** 它是用于MS-Excel中XLSX文件格式。
- **HPSF (可怕的属性设置格式) :** 它用来提取MS-Office文件属性设置。
- **HWPF (可怕的字处理器格式) :** 它是用来读取和写入MS-Word的文档扩展名的文件。
- **XWPF (XML字处理器格式) :** 它是用来读取和写入MS-Word的docx扩展名的文件。
- **HSLF (可怕的幻灯片版式格式) :** 它是用于读取，创建和编辑PowerPoint演示文稿。
- **HDGF (可怕的图表格式) :** 它包含类和方法为MS-Visio的二进制文件。
- **HPBF (可怕的出版商格式) :** 它被用来读取和写入MS-Publisher文件。

本教程将指导使用Java Excel文件完成工作过程。因此，本教程仅限于HSSF和XSSF组件。

**注：**旧版本的POI支持二进制文件格式，如DOC，XLS，PPT等从版本3.5起，POI支持微软Office的OOXML文件格式，如DOCX，XLSX，PPTX等。

如Apache POI，还有由不同的供应商为Excel文件的生成提供的其他库。这些措施包括Aspose面向Java的Aspose，JXL 通过共享库由JExcel团队开发。

# Apache POI - Java Excel APIs



本章将介绍一些Java ExcelAPI和它们的特征。有许多厂商谁提供Java Excel相关的API;其中一些将在这一章中讨论。

## **Java Aspose Cells**

Java Aspose Cells 是一种纯粹的Java授权的Excel API，开发和供应商Aspose发布。这个API的最新版本是8.1.2，发布于2014年7月，是一个丰富而厚重的API(普通Java类和AWT类的组合)设计，可以读、写和操纵电子表格Excel的组件。此API常见用途如下：

- Excel报表，建立动态Excel报表
- 高保真的Excel渲染和打印
- 从Excel电子表格中导入和导出数据
- 生成，编辑，转换和电子表格

##  

## **JXL**

JXL是一款专为Selenium第三方框架，支持基于Web浏览器(数据是Web浏览器自动更新)数据驱动的自动化。然而，它也被用来作为JExcel API的一个共同的支持库，因为它的基本功能是可创建，读取和写入电子表格。基本特征如下：

- 生成Excel文件
- 从工作簿和电子表格导入数据
- 获得行和列的总数

注意：JXL只支持xls档案格式，并且不能处理大数据量。

##  

## **JExcel**

JExcel是由Team Dev开发提供纯行货API。利用这一点程序员可以很容易地读取，写入，显示和修改Excel工作簿中的两种格式：.xls和.XLSX。这个API可以很容易地嵌入Java的Swing和AWT。这个API的最新版本是Jexcel-2.6.12，发布于2009年，主要特点如下。

- 自动化Excel应用程序，工作簿，工作表等
- 在Java Swing应用程序作为普通的Swing组件嵌入到工作簿
- 事件侦听器添加到工作簿和电子表格
- 添加事件处理程序来处理的工作簿和电子表格事件的行为
- 添加本地对等开发定制功能

##  

## **Apache POI**

Apache POI是Apache软件基金会提供的100％开源库。大多数中小规模的应用程序开发主要依赖于Apache POI（HSSF+ XSSF）。它支持Excel 库的所有基本功能; 然而，呈现和文本提取是它的主要特点。

![Apache POI - Java Excel APIs](http://www.manongjc.com/images/jiaochen/Apache_POI.jpg)

# POI核心类



本章介绍了Apache POI的API，它是至关重要的工作，使用Java程序操作Excel文件有下面几个类和方法。

## **工作簿**

这是创建或维护Excel工作簿的所有类的超接口。它属于org.apache.poi.ss.usermodel包。是实现此接口的两个类，如下所示：

- HSSFWorkbook : 这个类有读取和.xls 格式和写入Microsoft Excel文件的方法。它与微软Office97-2003版本兼容。
- XSSFWorkbook : 这个类有读写Microsoft Excel和OpenOffice的XML文件的格式.xls或.xlsx的方法。它与MS-Office版本2007或更高版本兼容。

##  

## **HSSFWorkbook**

它是在org.apache.poi.hssf.usermodel包的高层次的类。它实现了Workbook 接口，用于Excel文件中的.xls格式。下面列出的是一些本类下的方法和构造函数。

### 类的构造函数

| S.No. | 构造函数和说明                                               |
| ----- | ------------------------------------------------------------ |
| 1     | **HSSFWorkbook()**从头开始创建一个新的HSSFWorkbook对象时。   |
| 2     | **HSSFWorkbook(DirectoryNode directory, boolean preserveNodes)**创建一个特定的目录中一个新的HSSFWworkbook对象。 |
| 3     | **HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, boolean preserveNodes)**给定一个POIFSFileSystem对象和特定的目录中，它创建了一个SSFWorkbook对象读取指定的工作簿。 |
| 4     | **HSSFWorkbook(java.io.InputStream s)**创建使用输入流中的新HSSFWorkbook对象时。 |
| 5     | **HSSFWorkbook(java.io.InputStream s, boolean preserveNodes)**构建在输入流的POI文件系统。 |
| 6     | **HSSFWorkbook(POIFSFileSystem fs)**使用POIFSFileSystem对象构造的新HSSFWorkbook对象时。 |
| 7     | **HSSFWorkbook(POIFSFileSystem fs, boolean preserveNodes)**给定一个POIFSFileSystem对象时，它会创建一个新的HSSFWorkbook对象时读取指定的工作簿。 |

这些构造内的常用参数：

- directory : 这是从POI文件系统处理的目录。
- fs :它是包含簿流该POI的文件系统。
- preservenodes : 这是决定是否保留其他节点像宏的可选参数。它消耗大量的内存，因为它存储在内存中的所有POIFileSystem(如果设置)。

注意：HSSFWorkbook类包含了许多方法;然而，它们仅与XLS格式兼容。在本教程中，重点是在Excel文件格式的最新版本。因此，HSSFWorkbook类的方法，这里没有列出。如果需要这些类的方法，那么请参照POI-HSSFWorkbook类API在 https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFWorkbook.html.

##  

## **XSSFWorkbook**

它是用于表示高和低层次Excel文件格式的类。它属于org.apache.xssf.usemodel包，并实现Workbook接口。下面列出的是这个类的方法和构造函数。

### 类的构造函数

| S.No. | 构造函数和说明                                               |
| ----- | ------------------------------------------------------------ |
| 1     | **XSSFWorkbook()**从头开始创建一个新的XSSFworkbook对象。     |
| 2     | **XSSFWorkbook(java.io.File file)**构造从给定文件中的XSSFWorkbook对象。 |
| 3     | **XSSFWorkbook(java.io.InputStream is)**构造一个XSSFWorkbook对象，通过缓冲整个输入流到内存中，然后为它打开一个OPCPackage对象。 |
| 4     | **XSSFWorkbook(java.lang.String path)**构建一个给定文件的完整路径的XSSFWorkbook对象。 |

### 类方法

| S.No. | 方法及描述                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **createSheet()**创建一个XSSFSheet本工作簿，将其添加到表，并返回高层表示。 |
| 2     | **createSheet(java.lang.String sheetname)**创建此工作簿的新表，并返回高层表示。 |
| 3     | **createFont()**创建一个新的字体，并将其添加到工作簿的字体表。 |
| 4     | **createCellStyle()**创建一个新的XSSFCellStyle并将其添加到工作簿的样式表。 |
| 5     | **createFont()**创建一个新的字体，并将其添加到工作簿的字体表。 |
| 6     | **setPrintArea(int sheetIndex, int startColumn, int endColumn, int startRow,int endRow)**设置一个给定的表按照指定参数的打印区域。 |

对于此类的其余的方法，请参阅完整的API文档：[http://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFWorkbook.html.](http://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFWorkbook.html) 列出了所有方法。

 

## **Sheet**

Sheet是在org.apache.poi.ss.usermodel包的接口，它是创建具有特定名称的高或低级别的电子表格的所有类的超接口。电子表格的最常见的类型是工作表，它被表示为单元的网格。

 

## **HSSFSheet**

这是在org.apache.poi.hssf.usermodel包的类。它可以创建Excel电子表格，它允许在sheet 方式和表数据格式。

### 类的构造函数

| S.No. | 构造函数及描述                                               |
| ----- | ------------------------------------------------------------ |
| 1     | **HSSFSheet(HSSFWorkbook workbook)**创建新HSSFSheet通过调用HSSFWorkbook从头开始创建一个表。 |
| 2     | **HSSFSheet(HSSFWorkbook workbook, InternalSheet sheet)**创建HSSFSheet表示给定表对象。 |

##  

## **XSSFSheet**

这是代表了Excel电子表格的高级别代表的一类。这在org.apache.poi.hssf.usermodel包下。

### 类的构造函数

| S.No. | 构造函数及描述                                               |
| ----- | ------------------------------------------------------------ |
| 1     | **XSSFSheet()**创造了新的XSSFSheet- 调用XSSFWorkbook从头开始创建一个表。 |
| 2     | **XSSFSheet(PackagePart part, PackageRelationship rel)**创建XSSFSheet表示给定包的一部分和关系。 |

### 类方法

| S.No. | 方法和描述                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **addMergedRegion(CellRangeAddress region)**添加单元的合并区域（因此这些单元格合并形成一个）。 |
| 2     | **autoSizeColumn(int column)**调整列宽，以适应的内容。       |
| 3     | **iterator()**此方法是用于rowIterator()的别名，以允许foreach循环 |
| 4     | **addHyperlink(XSSFHyperlink hyperlink)**注册超链接的集合中的超链接此工作表格上 |

对于此类的其余的方法，请参阅完整的API在：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFSheet.html.

 

## **行**

这是在org.apache.poi.ss.usermodel包的接口。它是用于一排的电子表格的高层表示。它是代表了POI库的行所有类的超接口。

 

## **XSSFRow**

这是在org.apache.poi.xssf.usermodel包的类。它实现了Row接口，因此它可以在电子表格中创建行。下面列出的是这个类在方法和构造函数。

### 类方法

| S.No. | 描述                                                |
| ----- | --------------------------------------------------- |
| 1     | **createCell(int columnIndex)**创建新单元行并返回。 |
| 2     | **setHeight(short height)**设置短单位的高度。       |

对于此类的其余的方法，参考如下链接：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFRow.html

 

## **单元格**

这是在org.apache.poi.ss.usermodel包的接口。它是代表了单元在电子表格中的行中的所有类的超接口。

单元格可以使用各种属性，例如空白，数字，日期，错误等单元格被添加到一个行之前应具有（基于0）自己的编号。

 

## **XSSFCell**

这是在 org.apache.poi.xssf.usermodel 包的类。它实现了单元格界面。它是单元在电子表格中的行的一个高层次的表示。

 

## **字段摘要**

下面列出的是一些XSSFCell类的字段以及它们的描述。

| 单元格类型        | 描述                        |
| ----------------- | --------------------------- |
| CELL_TYPE_BLANK   | 代表空白单元格              |
| CELL_TYPE_BOOLEAN | 代表布尔单元（true或false） |
| CELL_TYPE_ERROR   | 表示在单元的误差值          |
| CELL_TYPE_FORMULA | 表示一个单元格公式的结果    |
| CELL_TYPE_NUMERIC | 表示对一个单元的数字数据    |
| CELL_TYPE_STRING  | 表示对一个单元串（文本）    |

### 类方法

| S.No. | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| 1     | **setCellStyle(CellStyle style)**为单元格设置样式。          |
| 2     | **setCellType(int cellType)**设置单元格的类型（数字，公式或字符串）。 |
| 3     | **setCellValue(boolean value)**设置单元格一个布尔值          |
| 4     | **setCellValue(java.util.Calendar value)**设置一个日期值的单元格。 |
| 5     | **setCellValue(double value)**设置为单元格的数值。           |
| 6     | **setCellValue(java.lang.String str)**设置为单元格的字符串值。 |
| 7     | **setHyperlink(Hyperlink hyperlink)**分配超链接到该单元格。  |

对于这个类的剩余方法和字段，请访问以下链接查看详细：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFCell.html

 

## **XSSFCellStyle**

这是在org.apache.poi.xssf.usermodel包的类。它将提供关于在电子表格的单元格中的内容的格式可能的信息。它也提供了用于修正该格式的选项。它实现了CellStyle接口。

### 字段摘要

下表列出了从CellStyle接口继承一些字段。

| 字段名称               | 字段描述                   |
| ---------------------- | -------------------------- |
| ALIGN_CENTER           | 中心对齐单元格内容         |
| ALIGN_CENTER_SELECTION | 中心选择水平对齐方式       |
| ALIGN_FILL             | 单元格适应于内容的大小     |
| ALIGN_JUSTIFY          | 适应单元格内容的宽度       |
| ALIGN_LEFT             | 左对齐单元格内容           |
| ALIGN_RIGHT            | 右对齐单元格内容           |
| BORDER_DASH_DOT        | 使用破折号和点单元格样式   |
| BORDER_DOTTED          | 用虚线边框的单元格样式     |
| BORDER_DASHED          | 用虚线边框的单元格样式     |
| BORDER_THICK           | 厚厚的边框单元格样式       |
| BORDER_THIN            | 薄边框的单元格样式         |
| VERTICAL_BOTTOM        | 对齐单元格内容的垂直下方   |
| VERTICAL_CENTER        | 对齐单元格内容垂直居中     |
| VERTICAL_JUSTIFY       | 对齐和垂直对齐的单元格内容 |
| VERTICAL_TOP           | 顶部对齐为垂直对齐         |

### 类的构造函数

| S.No. | 构造函数及描述                                               |
| ----- | ------------------------------------------------------------ |
| 1     | **XSSFCellStyle(int cellXfId, int cellStyleXfId, StylesTable stylesSource, ThemesTable theme)**创建一个单元格样式，从所提供的部分 |
| 2     | **XSSFCellStyle(StylesTable stylesSource)**创建一个空的单元样式 |

### 类方法

设置边框的类型为单元格的底部边界

| S.No | 方法及描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **setAlignment(short align)**设置单元格为水平对齐的类型      |
| 2    | **setBorderBottom(short border)**                            |
| 3    | **setBorderColor(XSSFCellBorder.BorderSide side, XSSFColor color)**选定的边框颜色 |
| 4    | **setBorderLeft(Short border)**设置边界的类型单元格的左边框  |
| 5    | **setBorderRight(short border)**设置边框的类型为单元格的右边界 |
| 6    | **setBorderTop(short border)**设置边界的类型的单元上边框     |
| 7    | **setFillBackgroundColor(XSSFColor color)**设置表示为XSSFColor值背景填充颜色。 |
| 8    | **setFillForegroundColor(XSSFColor color)**设置表示为XSSFColor的值前景填充颜色。 |
| 9    | **setFillPattern(short fp)**指定单元格的填充信息模式和纯色填充单元。 |
| 10   | **setFont(Font font)**设置此样式的字体。                     |
| 11   | **setRotation(short rotation)**设置的旋转为在单元格中文本的程度。 |
| 12   | **setVerticalAlignment(short align)**设置单元类型为垂直取向。 |

对于这个类剩下的方法和字段，通过以下链接：
[https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFCellStyle.html](https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFCellStyle.html.)

 

## **HSSFColor**

这是在org.apache.poi.hssf.util包的类。它提供了不同的颜色作为嵌套类。通常这些嵌套类是使用自己的索引来表示。它实现了Color接口。

### 嵌套类

所有嵌套类这个类是静态的，每个类都有其索引。这些嵌套色类用于单元格格式，如单元格内容，边框，前景和背景。下面列出了一些的嵌套类。

| S.No. | 类名（颜色）           |
| ----- | ---------------------- |
| 1     | HSSFColor.AQUA         |
| 2     | HSSFColor.AUTOMATIC    |
| 3     | HSSFColor.BLACK        |
| 4     | HSSFColor.BLUE         |
| 5     | HSSFColor.BRIGHT_GREEN |
| 6     | HSSFColor.BRIGHT_GRAY  |
| 7     | HSSFColor.CORAL        |
| 8     | HSSFColor.DARK_BLUE    |
| 9     | HSSFColor.DARK_GREEN   |
| 10    | HSSFColor.SKY_BLUE     |
| 11    | HSSFColor.WHITE        |
| 12    | HSSFColor.YELLOW       |

### 类方法

这个类的只有一个方法是很重要的，并且用于获取索引值。

| S.No. | 方法和描述                                         |
| ----- | -------------------------------------------------- |
| 1     | **getIndex()**这种方法被用来获得一个嵌套类的索引值 |

对于其余的方法和嵌套类，请参阅以下链接：
https://poi.apache.org/apidocs/org/apache/poi/hssf/util/HSSFColor.html.

 

## **XSSFColor**

这是在org.apache.poi.xssf.usermodel包的类。它是用来表示在电子表格中的颜色。它实现了颜色的接口。下面列出的是它的一些方法和构造函数。

### 类的构造函数

| S.No. | Constructor and 描述                                         |
| ----- | ------------------------------------------------------------ |
| 1     | **XSSFColor()**创建XSSFColor的新实例。                       |
| 2     | **XSSFColor(byte[] rgb)**创建XSSFColor使用RGB的新实例。      |
| 3     | **XSSFColor(java.awt.Color clr)**创建XSSFColor使用Color类从AWT包的新实例。 |

### 类方法

| S.No. | 方法和描述                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **setAuto(boolean auto)**设置一个布尔值，表示ctColor是自动的，系统ctColor依赖。 |
| 2     | **setIndexed(int indexed)**设置索引ctColor值系统ctColor。    |

对于其余的方法，请访问以下链接：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFColor.html.

 

## **XSSFFont**

这是在org.apache.poi.xssf.usermodel包的类。它实现了Font接口，因此它可以处理工作簿中不同的字体。

### 类的构造函数

| S.No. | 构造函数和描述                          |
| ----- | --------------------------------------- |
| 1     | **XSSFFont()**创建一个新的XSSFont实例。 |

### 类方法

| S.No. | 方法和描述                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **setBold(boolean bold)**设置“bold”属性的布尔值。            |
| 2     | **setColor(short color)**设置索引颜色的字体。                |
| 3     | **setColor(XSSFColor color)**设置为标准Alpha RGB颜色值的字体颜色。 |
| 4     | **setFontHeight(short height)**设置在点的字体高度。          |
| 5     | **setFontName(java.lang.String name)**设置字体的名称。       |
| 6     | **setItalic(boolean italic)**设置“italic”属性一个布尔值。    |

对于其余的方法，通过以下链接：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFFont.html.

 

## **XSSFHyperlink**

这是在org.apache.poi.xssf.usermodel包的类。它实现了Hyperlink接口。它是用来连结设置为电子表格的单元格内容。

### 字段

属于此类的字段如下。这里，字段意味着使用超链接的类型。

| 字段          | 描述                           |
| ------------- | ------------------------------ |
| LINK_DOCUMENT | 用于连接任何其他文件           |
| LINK_EMAIL    | 用于链接的电子邮件             |
| LINK_FILE     | 用于以任何格式链接任何其他文件 |
| LINK_URL      | 用来连接一个网页URL            |

### 类方法

| S.No. | 方法及描述                                           |
| ----- | ---------------------------------------------------- |
| 1     | **setAddress(java.lang.String address)**超链接地址。 |

对于其余的方法，请访问以下链接：
https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFHyperlink.html

 

## **XSSFCreationHelper**

这是在org.apache.poi.xssf.usermodel包的类。它实现了CreationHelper接口。它被用作公式求值和设置超文本链接支持类。

### 类方法

| S.No. | 方法和描述                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **createFormulaEvaluator()**创建一个XSSFFormulaEvaluator例如，结果计算公式的单元格的对象。 |
| 2     | **createHyperlink(int type)**Creates a new XSSFHyperlink.    |

对于其余的方法，请参考以下链接：https://poi.apache.org/apidocs/org/apache/poi/xssf/usermodel/XSSFCreationHelper.html.

 

## **XSSFPrintSetup**

这是在org.apache.poi.xsssf.usermodel包下的类。它实现了PrintSetup接口。它是用来设置打印页面大小，面积，选项和设置。

### 类方法

| S.No. | 方法及说明                                                   |
| ----- | ------------------------------------------------------------ |
| 1     | **setLandscape(boolean ls)**设置一个布尔值，允许或阻止横向打印。 |
| 2     | **setLeftToRight(boolean ltor)**设置是否向左走向右或自上而下的顺序，同时打印。 |
| 3     | **setPaperSize(short size)**设置纸张尺寸。                   |

对于其余的方法，请访问以下链接：https://poi.apache.org/apidocs/org/apache/poi/hssf/usermodel/HSSFPrintSetup.html

# Apache POI工作簿



此处的术语“Workbook”指的Microsoft Excel文件。本章完成后，您将能够创建新的工作簿，并可以使用Java程序打开现有工作簿。

## **创建空白工作簿**

下面简单的程序来创建一个空白Microsoft Excel工作簿。

```java
import java.io.*;
import org.apache.poi.xssf.usermodel.*;
public class CreateWorkBook 
{
   public static void main(String[] args)throws Exception 
   {
      //Create Blank workbook
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      //Create file system using specific name
      FileOutputStream out = new FileOutputStream(
      new File("createworkbook.xlsx"));
      //write operation workbook using file out object 
      workbook.write(out);
      out.close();
      System.out.println("
      createworkbook.xlsx written successfully");
   }
}
```

让我们保存上面的Java代码为CreateWorkBook.java，然后编译并从命令提示符如下执行它：

```java
$javac CreateWorkBook.java
$java CreateWorkBook
```

如果系统环境配置了POI 库，它会编译和执行，并生成一个名为createworkbook.xlsx 在当前目录下的空白Excel文件并显示在命令提示符处键入以下输出。

```java
createworkbook.xlsx written successfully
```

##  

## **打开现有工作簿**

使用下面的代码打开现有的工作簿。

```java
import java.io.*;
import org.apache.poi.xssf.usermodel.*;
public class OpenWorkBook
{
   public static void main(String args[])throws Exception
   { 
      File file = new File("openworkbook.xlsx");
      FileInputStream fIP = new FileInputStream(file);
      //Get the workbook instance for XLSX file 
      XSSFWorkbook workbook = new XSSFWorkbook(fIP);
      if(file.isFile() && file.exists())
      {
         System.out.println(
         "openworkbook.xlsx file open successfully.");
      }
      else
      {
         System.out.println(
         "Error to open openworkbook.xlsx file.");
      }
   }
}
```

保存上面的Java代码为OpenWorkBook.java，然后编译并从命令提示符如下执行它：

```java
$javac OpenWorkBook.java
$java OpenWorkBook
```

这将编译和执行生成以下输出。

```java
openworkbook.xlsx file open successfully.
```

打开工作簿后，可以进行读取，并在上面写操作。

# Apache POI电子表格/Spreadsheet



本章将介绍如何创建一个电子表格，并使用Java操纵它。电子表格是在Excel文件中的页面;它包含具有特定名称的行和列。

读完本章后，将能够创建一个电子表格，并能在其上执行读取操作。

## **创建电子表格**

首先，让我们创建一个使用在前面的章节中讨论的引用的类的电子表格。按照前面的章节中，首先创建一个工作簿，然后我们就可以去，并创建一个表。

下面的代码片段用于创建电子表格。

```java
//Create Blank workbook
XSSFWorkbook workbook = new XSSFWorkbook(); 
//Create a blank spreadsheet
XSSFSheet spreadsheet = workbook.createSheet("Sheet Name");
```

##  

## **电子表格的行**

电子表格有一个网格布局。行和列被标识与特定的名称。该列标识字母和行用数字。

下面的代码片段用于创建一个行。

```java
XSSFRow row = spreadsheet.createRow((short)1);
```

##  

## **写入到电子表格**

让我们考虑雇员数据的一个例子。这里的雇员数据给出以表格形式。

| Emp Id | Emp Name | 称号              |
| ------ | -------- | ----------------- |
| Tp01   | Gopal    | Technical Manager |
| TP02   | Manisha  | Proof Reader      |
| Tp03   | Masthan  | Technical Writer  |
| Tp04   | Satish   | Technical Writer  |
| Tp05   | Krishna  | Technical Writer  |

以下代码是用来写上述数据到电子表格。

```java
import java.io.File;
import java.io.FileOutputStream;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class Writesheet 
{
   public static void main(String[] args) throws Exception 
   {
      //Create blank workbook
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      //Create a blank sheet
      XSSFSheet spreadsheet = workbook.createSheet( 
      " Employee Info ");
      //Create row object
      XSSFRow row;
      //This data needs to be written (Object[])
      Map < String, Object[] > empinfo = 
      new TreeMap < String, Object[] >();
      empinfo.put( "1", new Object[] { 
      "EMP ID", "EMP NAME", "DESIGNATION" });
      empinfo.put( "2", new Object[] { 
      "tp01", "Gopal", "Technical Manager" });
      empinfo.put( "3", new Object[] { 
      "tp02", "Manisha", "Proof Reader" });
      empinfo.put( "4", new Object[] { 
      "tp03", "Masthan", "Technical Writer" });
      empinfo.put( "5", new Object[] { 
      "tp04", "Satish", "Technical Writer" });
      empinfo.put( "6", new Object[] { 
      "tp05", "Krishna", "Technical Writer" });
      //Iterate over data and write to sheet
      Set < String > keyid = empinfo.keySet();
      int rowid = 0;
      for (String key : keyid)
      {
         row = spreadsheet.createRow(rowid++);
         Object [] objectArr = empinfo.get(key);
         int cellid = 0;
         for (Object obj : objectArr)
         {
            Cell cell = row.createCell(cellid++);
            cell.setCellValue((String)obj);
         }
      }
      //Write the workbook in file system
      FileOutputStream out = new FileOutputStream( 
      new File("Writesheet.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println( 
      "Writesheet.xlsx written successfully" );
   }
}
```

上面的Java代码保存为Writesheet.java，然后并在命令提示符下编译运行，如下所示：

```java
$javac Writesheet.java
$java Writesheet
```

这将编译和执行来生成一个Excel文件名为Writesheet.xlsx在当前目录中，在命令提示符处键入以下输出。

```java
Writesheet.xlsx written successfully
```

Writesheet.xlsx文件的内容如下所示。

![Apache POI电子表格/Spreadsheet](http://www.manongjc.com/images/jiaochen/apache_opi_spreadsheet.jpg)

##  

## **从电子表格读取数据**

让我们考虑上述excel文件命名Writesheet.xslx作为输入文件。注意下面的代码;它是用于从电子表格中读取数据。

```java
import java.io.File;
import java.io.FileInputStream;
import java.util.Iterator;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class Readsheet 
{
   static XSSFRow row;
   public static void main(String[] args) throws Exception 
   {
      FileInputStream fis = new FileInputStream(
      new File("WriteSheet.xlsx"));
      XSSFWorkbook workbook = new XSSFWorkbook(fis);
      XSSFSheet spreadsheet = workbook.getSheetAt(0);
      Iterator < Row > rowIterator = spreadsheet.iterator();
      while (rowIterator.hasNext()) 
      {
         row = (XSSFRow) rowIterator.next();
         Iterator < Cell > cellIterator = row.cellIterator();
         while ( cellIterator.hasNext()) 
         {
            Cell cell = cellIterator.next();
            switch (cell.getCellType()) 
            {
               case Cell.CELL_TYPE_NUMERIC:
               System.out.print( 
               cell.getNumericCellValue() + " \t\t " );
               break;
               case Cell.CELL_TYPE_STRING:
               System.out.print(
               cell.getStringCellValue() + " \t\t " );
               break;
            }
         }
         System.out.println();
      }
      fis.close();
   }
}
```

让我们把上面的代码保存在Readsheet.java文件，然后编译并在命令提示符下运行，如下所示：

```java
$javac Readsheet.java
$java Readsheet
```

如果您的系统环境配置了POI库，它会编译和执行产生在命令提示符处键入以下输出。

```java
EMP ID EMP NAME DESIGNATION 
 tp01   Gopal    Technical Manager 
 tp02   Manisha  Proof Reader 
 tp03   Masthan  Technical Writer 
 tp04   Satish   Technical Writer 
 tp05   Krishna  Technical Writer
```

# Apache POI单元格/Cells



输入到电子表格中的任何数据总是存储在一个单元中。我们使用的行和列的标签来识别单元格。本章介绍了如何使用Java编程操纵单元电子表格的数据。

## **创建一个单元格**

需要创建一个单元之前创建一个行。行是什么？只不过是单元的集合。

下面的代码片段用于创建一个单元格。

```java
//create new workbook
XSSFWorkbook workbook = new XSSFWorkbook(); 
//create spreadsheet with a name
XSSFSheet spreadsheet = workbook.createSheet("new sheet");
//create first row on a created spreadsheet
XSSFRow row = spreadsheet.createRow(0);
//create first cell on created row
XSSFCell cell = row.createCell(0);
```

##  

## **单元格类型**

单元格类型指定单元格是否可以包含字符串，数值，或公式。字符串单元不能持有数值和数值单元格无法容纳字符串。下面给出是单元格值和类型的语法。

| 单元格的值类型     | 类型语法                   |
| ------------------ | -------------------------- |
| Blank cell value   | XSSFCell.CELL_TYPE_BLANK   |
| Boolean cell value | XSSFCell.CELL.TYPE_BOOLEAN |
| Error cell value   | XSSFCell.CELL_TYPE_ERROR   |
| Numeric cell value | XSSFCell.CELL_TYPE_NUMERIC |
| String cell value  | XSSFCell.CELL_TYPE_STRING  |

以下代码是用于在电子表格创建不同类型的单元格。

```java
import java.io.File;
import java.io.FileOutputStream;
import java.util.Date;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class TypesofCells 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook.createSheet("cell types");
      XSSFRow row = spreadsheet.createRow((short) 2);
      row.createCell(0).setCellValue("Type of Cell");
      row.createCell(1).setCellValue("cell value");
      row = spreadsheet.createRow((short) 3);
      row.createCell(0).setCellValue("set cell type BLANK");
      row.createCell(1);
      row = spreadsheet.createRow((short) 4);
      row.createCell(0).setCellValue("set cell type BOOLEAN");
      row.createCell(1).setCellValue(true);
      row = spreadsheet.createRow((short) 5);
      row.createCell(0).setCellValue("set cell type ERROR");
      row.createCell(1).setCellValue(XSSFCell.CELL_TYPE_ERROR );
      row = spreadsheet.createRow((short) 6);
      row.createCell(0).setCellValue("set cell type date");
      row.createCell(1).setCellValue(new Date());
      row = spreadsheet.createRow((short) 7);
      row.createCell(0).setCellValue("set cell type numeric" );
      row.createCell(1).setCellValue(20 );
      row = spreadsheet.createRow((short) 8);
      row.createCell(0).setCellValue("set cell type string");
      row.createCell(1).setCellValue("A String");
      FileOutputStream out = new FileOutputStream(
      new File("typesofcells.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println(
      "typesofcells.xlsx written successfully");
   }
}
```

保存上面的代码到一个名为TypesofCells.java文件，编译并从命令提示符如下执行它。

```java
$javac TypesofCells.java
$java TypesofCells
```

如果您的系统配置了POI库，那么它会编译和执行在当前目录中生成一个名为typesofcells.xlsx的Excel文件，并显示以下输出。

```java
typesofcells.xlsx written successfully
```

typesofcells.xlsx文件如下所示。

![Apache POI单元格/Cells](http://www.manongjc.com/images/jiaochen/apache_poi_cells-1.jpg)

##  

## **单元格样式**

在这里，可以学习如何做单元格格式，并采用不同的风格，如合并相邻的单元格，添加边框，设置单元格对齐方式和填充颜色。

以下代码是使用Java编程用于不同样式应用到单元格。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class CellStyle 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook.createSheet("cellstyle");
      XSSFRow row = spreadsheet.createRow((short) 1);
      row.setHeight((short) 800);
      XSSFCell cell = (XSSFCell) row.createCell((short) 1);
      cell.setCellValue("test of merging");
      //MEARGING CELLS 
      //this statement for merging cells
      spreadsheet.addMergedRegion(new CellRangeAddress(
      1, //first row (0-based)
      1, //last row (0-based)
      1, //first column (0-based)
      4 //last column (0-based)
      ));
      //CELL Alignment
      row = spreadsheet.createRow(5); 
      cell = (XSSFCell) row.createCell(0);
      row.setHeight((short) 800);
      // Top Left alignment 
      XSSFCellStyle style1 = workbook.createCellStyle();
      spreadsheet.setColumnWidth(0, 8000);
      style1.setAlignment(XSSFCellStyle.ALIGN_LEFT);
      style1.setVerticalAlignment(XSSFCellStyle.VERTICAL_TOP);
      cell.setCellValue("Top Left");
      cell.setCellStyle(style1);
      row = spreadsheet.createRow(6); 
      cell = (XSSFCell) row.createCell(1);
      row.setHeight((short) 800);
      // Center Align Cell Contents 
      XSSFCellStyle style2 = workbook.createCellStyle();
      style2.setAlignment(XSSFCellStyle.ALIGN_CENTER);
      style2.setVerticalAlignment( 
      XSSFCellStyle.VERTICAL_CENTER);
      cell.setCellValue("Center Aligned"); 
      cell.setCellStyle(style2);
      row = spreadsheet.createRow(7); 
      cell = (XSSFCell) row.createCell(2);
      row.setHeight((short) 800);
      // Bottom Right alignment 
      XSSFCellStyle style3 = workbook.createCellStyle();
      style3.setAlignment(XSSFCellStyle.ALIGN_RIGHT);
      style3.setVerticalAlignment( 
      XSSFCellStyle.VERTICAL_BOTTOM);
      cell.setCellValue("Bottom Right");
      cell.setCellStyle(style3);
      row = spreadsheet.createRow(8);
      cell = (XSSFCell) row.createCell(3);
      // Justified Alignment 
      XSSFCellStyle style4 = workbook.createCellStyle();
      style4.setAlignment(XSSFCellStyle.ALIGN_JUSTIFY);
      style4.setVerticalAlignment(
      XSSFCellStyle.VERTICAL_JUSTIFY);
      cell.setCellValue("Contents are Justified in Alignment"); 
      cell.setCellStyle(style4);
      //CELL BORDER
      row = spreadsheet.createRow((short) 10);
      row.setHeight((short) 800);
      cell = (XSSFCell) row.createCell((short) 1);
      cell.setCellValue("BORDER");
      XSSFCellStyle style5 = workbook.createCellStyle();
      style5.setBorderBottom(XSSFCellStyle.BORDER_THICK);
      style5.setBottomBorderColor(
      IndexedColors.BLUE.getIndex());
      style5.setBorderLeft(XSSFCellStyle.BORDER_DOUBLE);
      style5.setLeftBorderColor( 
      IndexedColors.GREEN.getIndex());
      style5.setBorderRight(XSSFCellStyle.BORDER_HAIR);
      style5.setRightBorderColor( 
      IndexedColors.RED.getIndex());
      style5.setBorderTop(XSSFCellStyle.BIG_SPOTS);
      style5.setTopBorderColor( 
      IndexedColors.CORAL.getIndex());
      cell.setCellStyle(style5);
      //Fill Colors
      //background color
      row = spreadsheet.createRow((short) 10 );
      cell = (XSSFCell) row.createCell((short) 1);
      XSSFCellStyle style6 = workbook.createCellStyle();
      style6.setFillBackgroundColor(
      HSSFColor.LEMON_CHIFFON.index );
      style6.setFillPattern(XSSFCellStyle.LESS_DOTS);
      style6.setAlignment(XSSFCellStyle.ALIGN_FILL);
      spreadsheet.setColumnWidth(1,8000);
      cell.setCellValue("FILL BACKGROUNG/FILL PATTERN");
      cell.setCellStyle(style6);
      //Foreground color
      row = spreadsheet.createRow((short) 12);
      cell = (XSSFCell) row.createCell((short) 1);
      XSSFCellStyle style7=workbook.createCellStyle();
      style7.setFillForegroundColor(HSSFColor.BLUE.index);
      style7.setFillPattern( XSSFCellStyle.LESS_DOTS);
      style7.setAlignment(XSSFCellStyle.ALIGN_FILL);
      cell.setCellValue("FILL FOREGROUND/FILL PATTERN");
      cell.setCellStyle(style7);
      FileOutputStream out = new FileOutputStream(
      new File("cellstyle.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println("cellstyle.xlsx written successfully");
   }
}
```

保存上面的代码在一个名为CellStyle.java文件，编译并从命令提示符如下执行它。

```java
$javac CellStyle.java
$java CellStyle
```

它会生成一个名为cellstyle.xlsx在当前目录中的Excel文件并显示以下输出。

```java
cellstyle.xlsx written successfully
```

cellstyle.xlsx文件如下所示。

![Apache POI单元格/Cells](http://www.manongjc.com/images/jiaochen/apache_poi_cells-2.jpg)

# Apache POI字体/Fonts



本章介绍如何设置不同的字体，应用样式，并在Excel电子表格中显示的方向不同角度的文字。

每个系统附带一个很大的字体如 Arial, Impact, Times New Roman,等字体集合也可以用新的字体更新，如果需要的话。同样也有各种风格，其中的字体可以显示，例如，粗体，斜体，下划线，删除线等。

## **字体和字体样式**

下面的代码用于特定的字体和样式应用于一单元格的内容。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class FontStyle 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook.createSheet("Fontstyle");
      XSSFRow row = spreadsheet.createRow(2);
      //Create a new font and alter it.
      XSSFFont font = workbook.createFont();
      font.setFontHeightInPoints((short) 30);
      font.setFontName("IMPACT");
      font.setItalic(true);
      font.setColor(HSSFColor.BRIGHT_GREEN.index);
      //Set font into style
      XSSFCellStyle style = workbook.createCellStyle();
      style.setFont(font);
      // Create a cell with a value and set style to it.
      XSSFCell cell = row.createCell(1);
      cell.setCellValue("Font Style");
      cell.setCellStyle(style);
      FileOutputStream out = new FileOutputStream(
      new File("fontstyle.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println(
      "fontstyle.xlsx written successfully");
   }
}
```

让我们保存上面的代码在一个名为FontStyle.java文件。从命令提示符编译并执行它如下。

```java
$javac FontStyle.java
$java FontStyle
```

它生成一个名为fontstyle.xlsx在当前目录中的Excel文件并显示在命令提示符处键入以下输出。

```java
fontstyle.xlsx written successfully
```

fontstyle.xlsx文件如下所示。

![Apache POI字体/Fonts](http://www.manongjc.com/images/jiaochen/apache_poi_fonts_1.jpg)

##  

## **文字方向**

在这里，可以学习如何设置不同角度的文本方向。通常单元格的内容以水平方式显示，由左到右，并在00角;但是可以使用下面的代码来旋转文本的方向(如果需要的话)。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class TextDirection 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook.createSheet(
      "Text direction");
      XSSFRow row = spreadsheet.createRow(2);
      XSSFCellStyle myStyle = workbook.createCellStyle();
      myStyle.setRotation((short) 0);
      XSSFCell cell = row.createCell(1);
      cell.setCellValue("0D angle");
      cell.setCellStyle(myStyle);
      //30 degrees
      myStyle=workbook.createCellStyle();
      myStyle.setRotation((short) 30);
      cell = row.createCell(3);
      cell.setCellValue("30D angle");
      cell.setCellStyle(myStyle);
      //90 degrees
      myStyle=workbook.createCellStyle();
      myStyle.setRotation((short) 90);
      cell = row.createCell(5);
      cell.setCellValue("90D angle");
      cell.setCellStyle(myStyle);
      //120 degrees
      myStyle=workbook.createCellStyle();
      myStyle.setRotation((short) 120);
      cell = row.createCell(7);
      cell.setCellValue("120D angle");
      cell.setCellStyle(myStyle);
      //270 degrees
      myStyle = workbook.createCellStyle();
      myStyle.setRotation((short) 270);
      cell = row.createCell(9);
      cell.setCellValue("270D angle");
      cell.setCellStyle(myStyle);
      //360 degrees
      myStyle=workbook.createCellStyle();
      myStyle.setRotation((short) 360);
      cell = row.createCell(12);
      cell.setCellValue("360D angle");
      cell.setCellStyle(myStyle);
      FileOutputStream out = new FileOutputStream(
      new File("textdirection.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println( 
      "textdirection.xlsx written successfully");
   }
}
```

保持TextDirectin.java文件上面的代码，然后编译并从命令提示符如下执行它。

```java
$javac TextDirection.java
$java TextDirection
```

这将编译和执行，以生成一个名为textdirection.xlsx在当前目录中的Excel文件并显示在命令提示符处键入以下输出。

```java
textdirection.xlsx written successfully
```

textdirection.xlsx文件如下所示。

![Apache POI字体/Fonts](http://www.manongjc.com/images/jiaochen/apache_poi_fonts_2.jpg)

# Apache POI公式



本章将介绍如何使用Java编程应用不同单元公式的过程。 Excel应用程序的基本目的是通过应用公式就可以保持数值数据。

在公式中，我们通过动态值，或在Excel工作表中的值的位置。在执行这个公式，就会得到想要的结果。下表列出了常用的在Excel中的几个基本公式。

| 操作           | 语法                                         |
| -------------- | -------------------------------------------- |
| 添加多个数值   | = SUM(Loc1:Locn) or = SUM(n1,n2,)            |
| 计数           | = COUNT(Loc1:Locn) or = COUNT(n1,n2,)        |
| 两个数的幂     | = POWER(Loc1,Loc2) or = POWER(number, power) |
| 多个数的最大值 | = MAX(Loc1:Locn) or = MAX(n1,n2,)            |
| 乘积           | = PRODUCT(Loc1:Locn) or = PRODUCT(n1,n2,)    |
| 阶乘           | = FACT(Locn) or = FACT(number)               |
| 绝对数字       | = ABS(Locn) or = ABS(number)                 |
| 今天的日期     | =TODAY()                                     |
| 转换成小写     | = LOWER(Locn) or = LOWER(text)               |
| 平方根         | = SQRT(locn) or = SQRT(number)               |

以下代码用于公式添加至单元格，并执行它。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class Formula 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook.createSheet("formula");
      XSSFRow row = spreadsheet.createRow(1);
      XSSFCell cell = row.createCell(1);
      cell.setCellValue("A =" );
      cell = row.createCell(2);
      cell.setCellValue(2);
      row = spreadsheet.createRow(2);
      cell = row.createCell(1);
      cell.setCellValue("B =");
      cell = row.createCell(2);
      cell.setCellValue(4);
      row = spreadsheet.createRow(3);
      cell = row.createCell(1);
      cell.setCellValue("Total =");
      cell = row.createCell(2);
      // Create SUM formula
      cell.setCellType(XSSFCell.CELL_TYPE_FORMULA);
      cell.setCellFormula("SUM(C2:C3)" );
      cell = row.createCell(3);
      cell.setCellValue("SUM(C2:C3)");
      row = spreadsheet.createRow(4);
      cell = row.createCell(1);
      cell.setCellValue("POWER =");
      cell=row.createCell(2);
      // Create POWER formula
      cell.setCellType(XSSFCell.CELL_TYPE_FORMULA);
      cell.setCellFormula("POWER(C2,C3)");
      cell = row.createCell(3);
      cell.setCellValue("POWER(C2,C3)");
      row = spreadsheet.createRow(5);
      cell = row.createCell(1);
      cell.setCellValue("MAX =");
      cell = row.createCell(2);
      // Create MAX formula
      cell.setCellType(XSSFCell.CELL_TYPE_FORMULA);
      cell.setCellFormula("MAX(C2,C3)");
      cell = row.createCell(3);
      cell.setCellValue("MAX(C2,C3)");
      row = spreadsheet.createRow(6);
      cell = row.createCell(1);
      cell.setCellValue("FACT =");
      cell = row.createCell(2);
      // Create FACT formula
      cell.setCellType(XSSFCell.CELL_TYPE_FORMULA);
      cell.setCellFormula("FACT(C3)");
      cell = row.createCell(3);
      cell.setCellValue("FACT(C3)");
      row = spreadsheet.createRow(7);
      cell = row.createCell(1);
      cell.setCellValue("SQRT =");
      cell = row.createCell(2);
      // Create SQRT formula
      cell.setCellType(XSSFCell.CELL_TYPE_FORMULA);
      cell.setCellFormula("SQRT(C5)");
      cell = row.createCell(3);
      cell.setCellValue("SQRT(C5)");
      workbook.getCreationHelper()
      .createFormulaEvaluator()
      .evaluateAll();
      FileOutputStream out = new FileOutputStream(
      new File("formula.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println("fromula.xlsx written successfully");
   }
}
```

保存上面的代码到文件Formula.java，然后编译并从命令提示符如下执行它。

```java
$javac Formula.java
$java Formula
```

它会生成一个名为formula.xlsx在当前目录中的Excel文件并显示在命令提示符处键入以下输出。

```java
fromula.xlsx written successfully
```

formula.xlsx文件如下所示。

![Apache POI公式](http://www.manongjc.com/images/jiaochen/apache_poi_formula.jpg)

# Apache POI超链接



本章介绍了如何为超链接添加到内容的单元格。超链接通常被用来访问任何网站的网址，电子邮件或外部文件。

下面的代码演示如何创建单元格的超链接。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.common.usermodel.Hyperlink;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFHyperlink;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class HyperlinkEX 
{
   public static void main(String[] args) throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook
      .createSheet("Hyperlinks");
      XSSFCell cell;
      CreationHelper createHelper = workbook
      .getCreationHelper();
      XSSFCellStyle hlinkstyle = workbook.createCellStyle();
      XSSFFont hlinkfont = workbook.createFont();
      hlinkfont.setUnderline(XSSFFont.U_SINGLE);
      hlinkfont.setColor(HSSFColor.BLUE.index);
      hlinkstyle.setFont(hlinkfont);
      //URL Link
      cell = spreadsheet.createRow(1)
      .createCell((short) 1);
      cell.setCellValue("URL Link");
      XSSFHyperlink link = (XSSFHyperlink)createHelper
      .createHyperlink(Hyperlink.LINK_URL);
      link.setAddress("http://www.manongjc.com/" );
      cell.setHyperlink((XSSFHyperlink) link);
      cell.setCellStyle(hlinkstyle);
      //Hyperlink to a file in the current directory
      cell = spreadsheet.createRow(2)
      .createCell((short) 1);
      cell.setCellValue("File Link");
      link = (XSSFHyperlink)createHelper
      .createHyperlink(Hyperlink.LINK_FILE);
      link.setAddress("cellstyle.xlsx");
      cell.setHyperlink(link);
      cell.setCellStyle(hlinkstyle);
      //e-mail link
      cell = spreadsheet.createRow(3)
      .createCell((short) 1);
      cell.setCellValue("Email Link");
      link = (XSSFHyperlink)createHelper
      .createHyperlink(Hyperlink.LINK_EMAIL);
      link.setAddress( 
      "mailto:contact@manongjc.com?"
      +"subject=Hyperlink");
      cell.setHyperlink(link);
      cell.setCellStyle(hlinkstyle);
      FileOutputStream out = new FileOutputStream(
      new File("hyperlink.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println("hyperlink.xlsx written successfully");
   }
}
```

保存上面的代码到文件HyperlinkEX.java。并从命令提示符编译执行它如下。

```java
$javac HyperlinkEX.java
$java HyperlinkEX
```

它会生成一个名为hyperlink.xlsx在当前目录中的Excel文件并显示在命令提示符处输出：

```java
hyperlink.xlsx written successfully
```

hyperlink.xlsx文件如下所示。

![Apache POI超链接](http://www.manongjc.com/images/jiaochen/apache_poi_hyperlink.jpg)

# Apache POI打印区域



本章介绍了如何在电子表格中设置打印区域。通常打印区域从左上角到Excel电子表格右下角。打印区域可根据要求进行定制。它意味着可以从整个电子表格打印单元的特定范围，自定义的纸张大小，用网格线打印的内容接通等

以下代码是用来在电子表格中设置打印区域。

```java
import java.io.File;
import java.io.FileOutputStream;
import org.apache.poi.xssf.usermodel.XSSFPrintSetup;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class PrintArea 
{
   public static void main(String[] args)throws Exception 
   {
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook
      .createSheet("Print Area");
      //set print area with indexes
      workbook.setPrintArea(
      0, //sheet index
      0, //start column
      5, //end column
      0, //start row
      5 //end row
      );
      //set paper size
      spreadsheet.getPrintSetup().setPaperSize(
      XSSFPrintSetup.A4_PAPERSIZE);
      //set display grid lines or not
      spreadsheet.setDisplayGridlines(true);
     //set print grid lines or not
     spreadsheet.setPrintGridlines(true);
     FileOutputStream out = new FileOutputStream(
     new File("printarea.xlsx"));
     workbook.write(out);
     out.close();
     System.out.println("printarea.xlsx written successfully"); 
   }
}
```

让我们保存了上面的代码为PrintArea.java。编译并从命令提示符执行它如下。

```java
$javac PrintArea.java
$java PrintArea
```

它会生成一个名为printarea.xlsx在当前目录下的文件，并显示在命令提示符处输出以下。

```java
printarea.xlsx written successfully
```

在上面的代码中，我们还没有添加任何单元格值。因此printarea.xlsx是一个空白文件。但是可以在下图的打印预览显示网格线打印区域查看。

![Apache POI打印区域](http://www.manongjc.com/images/jiaochen/apache_poi_print_area.jpg)

# Apache POI数据库



本章介绍了POI库与数据库的交互方式。有了JDBC帮助，可以从数据库中检索数据并插入数据来使用POI库电子表格。让我们考虑SQL操作MySQL数据库。

## **写入数据库**

让我们假设数据表是 emp_tbl 存有雇员信息是从MySQL数据库 test 中检索。

| EMP ID | EMP NAME    | DEG               | SALARY | DEPT    |
| ------ | ----------- | ----------------- | ------ | ------- |
| 1201   | Gopal       | Technical Manager | 45000  | IT      |
| 1202   | Manisha     | Proof reader      | 45000  | Testing |
| 1203   | Masthanvali | Technical Writer  | 45000  | IT      |
| 1204   | Kiran       | Hr Admin          | 40000  | HR      |
| 1205   | Kranthi     | Op Admin          | 30000  |         |

使用下面的代码从数据库中检索数据，并插入到同一个电子表格。

```java
import java.io.File;
import java.io.FileOutputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
public class ExcelDatabase 
{
   public static void main(String[] args) throws Exception 
   {
      Class.forName("com.mysql.jdbc.Driver");
      Connection connect = DriverManager.getConnection( 
      "jdbc:mysql://localhost:3306/test" , 
      "root" , 
      "root"
      );
      Statement statement = connect.createStatement();
      ResultSet resultSet = statement
      .executeQuery("select * from emp_tbl");
      XSSFWorkbook workbook = new XSSFWorkbook(); 
      XSSFSheet spreadsheet = workbook
      .createSheet("employe db");
      XSSFRow row=spreadsheet.createRow(1);
      XSSFCell cell;
      cell=row.createCell(1);
      cell.setCellValue("EMP ID");
      cell=row.createCell(2);
      cell.setCellValue("EMP NAME");
      cell=row.createCell(3);
      cell.setCellValue("DEG");
      cell=row.createCell(4);
      cell.setCellValue("SALARY");
      cell=row.createCell(5);
      cell.setCellValue("DEPT");
      int i=2;
      while(resultSet.next())
      {
         row=spreadsheet.createRow(i);
         cell=row.createCell(1);
         cell.setCellValue(resultSet.getInt("eid"));
         cell=row.createCell(2);
         cell.setCellValue(resultSet.getString("ename"));
         cell=row.createCell(3);
         cell.setCellValue(resultSet.getString("deg"));
         cell=row.createCell(4);
         cell.setCellValue(resultSet.getString("salary"));
         cell=row.createCell(5);
         cell.setCellValue(resultSet.getString("dept"));
         i++;
      }
      FileOutputStream out = new FileOutputStream(
      new File("exceldatabase.xlsx"));
      workbook.write(out);
      out.close();
      System.out.println(
      "exceldatabase.xlsx written successfully");
   }
}
```

让我们保存了上面的代码为ExcelDatabase.java。编译并从命令提示符执行它如下。

```java
$javac ExcelDatabase.java
$java ExcelDatabase
```

它会生成一个名为exceldatabase.xlsx在当前目录中的Excel文件并显示在命令提示符处输出以下。

```java
exceldatabase.xlsx written successfully
```

exceldatabase.xlsx文件如下所示。

![Apache POI数据库](http://www.manongjc.com/images/jiaochen/apache_poi_database.jpg)