---
title: 进程、线程以及多线程的认识
date: 2021-01-12 17:38:49
permalink: /pages/0393d0/
categories:
  - 后端
  - Java基础篇
tags:
  - 多线程
---

> 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易理解，特意拿出来总结一篇文章。



### ![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/%E5%8E%9F%E7%90%86%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.jpg)

## **进程**

我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序侧是具有某种功能的程序，程序是运行于操作系统之上的。

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

**进程具有的特征：**

动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

并发性：任何进程都可以同其他进程一起并发执行；

独立性：进程是系统进行资源分配和调度的一个独立单位；

结构性：进程由程序、数据集合和进程控制块三部分组成。

## **线程**

在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

 后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。 

### **进程与线程的区别**

1.线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

3.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；

4.调度和切换：线程上下文切换比进程上下文切换要快得多。

进程与线程的资源共享关系如下图：

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/915505-20180514150222322-337612318.png)



单线程与多线程的关系如下图：

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/915505-20180514150233853-1132667969.png)

 总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。

在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。

后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/915505-20180514150335698-1185040975.png)

### **多线程与多核**

 上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？

其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。

多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。

## 线程的生命周期

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/6516264-acdde18e59303351.png)

#### **新建状态**

我们来看下面一段代码：

```java
Thread t1 = ``new` `Thread();
```

这里的创建，仅仅是在JAVA的这种编程语言层面被创建，而在操作系统层面，真正的线程还没有被创建。只有当我们调用了 start() 方法之后，该线程才会被创建出来，进入Runnable状态。只有当我们调用了 start() 方法之后，该线程才会被创建出来。



![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/1223046-20190722214216437-864622217.png)



#### **就绪状态**

调用start()方法后，JVM 进程会去创建一个新的线程，而此线程不会马上被 CPU 调度运行，进入Running状态，这里会有一个中间状态，就是Runnable状态，你可以理解为等待被 CPU 调度的状态

```
t1.start()
```

用一张图表示如下：

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/1223046-20190722214334481-1436365111.png)

那么处于Runnable状态的线程能发生哪些状态转变？

Runnable状态的线程无法直接进入Blocked状态和Terminated状态的。只有处在Running状态的线程，换句话说，只有获得CPU调度执行权的线程才有资格进入Blocked状态和Terminated状态，Runnable状态的线程要么能被转换成Running状态，要么被意外终止。

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/1223046-20190722214414952-1788624892.png)

#### **运行状态**

当CPU调度发生，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法中逻辑代码。

那么处于Running状态的线程能发生哪些状态转变？

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/1223046-20190722214456212-734896654.png)

- 被转换成Terminated状态，比如调用 stop() 方法;
- 被转换成Blocked状态，比如调用了sleep, wait 方法被加入 waitSet 中；
- 被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态；
- 被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中；
- 该线程的时间片用完，CPU 再次调度，进入Runnable状态；
- 线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态

#### **阻塞状态**

Blocked状态的线程能够发生哪些状态改变？

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/1223046-20190722214547127-782461177.png)

- 被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash;

- 被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后；

- 完成了指定时间的休眠，进入到Runnable状态；

- 正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态；

- 线程获取到了想要的锁资源，进入Runnable状态；

- 线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态；

  

#### **终止状态**

一旦线程进入了Terminated状态，就意味着这个线程生命的终结，哪些情况下，线程会进入到Terminated状态呢？

- 线程正常运行结束，生命周期结束；
- 线程运行过程中出现意外错误；
- JVM 异常结束，所有的线程生命周期均被结束。

::: tip 名词解释
1、**等待阻塞：**运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
2、**同步阻塞：**运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
3、**其他阻塞：**运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）。
4、**线程睡眠**：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
5、**线程等待**：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。唤醒线程后，就转为就绪（Runnable）状态。
6、**线程让步**：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
7、**线程加入**：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
8、**线程I/O**：线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。
9、**线程唤醒**：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意性的，并在对实现做出决定时发生。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
:::



## 多线程

什么是多线程呢？即就是一个程序中有多个线程在同时执行。

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/12899166-4faed15a692f6f06.png)

- 单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如，去网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。
- 多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。

### 主线程

回想我们以前学习中写过的代码，当我们在dos命令行中输入java空格类名回车后，启动JVM，并且加载对应的class文件。虚拟机并会从main方法开始执行我们的程序代码，一直把main方法的代码执行结束。如果在执行过程遇到循环时间比较长的代码，那么在循环之后的其他代码是不会被马上执行的。

```java
class Demo{

String name;

Demo(String name){

   this.name = name;

}

void show() {

   for (int i=1;i<=10000 ;i++ ) {

        System.out.println("name="+name+",i="+i);

    }

}
}



class ThreadDemo {

public static void main(String[] args) {

         Demo d = new Demo("小强");

         Demo d2 = new Demo("旺财");

         d.show();

         d2.show();

         System.out.println("Hello World!");

}

}
```

若在上述代码中show方法中的循环执行次数很多，这时在d.show();下面的代码是不会马上执行的，并且在dos窗口会看到不停的输出name=小强,i=值，这样的语句。为什么会这样呢？

原因是：

jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。

那么，能否实现一个主线程负责执行其中一个循环，再由另一个线程负责其他代码的执行，最终实现多部分代码同时执行的效果？

能够实现同时执行，通过Java中的多线程技术来解决该问题。

###  为什么要用多线程

①、为了更好的利用cpu的资源，如果只有一个线程，则第二个任务必须等到第一个任务结束后才能进行，如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待；

②、进程之间不能共享数据，线程可以；

③、系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小；

④、Java语言内置了多线程功能支持，简化了java多线程编程。



###  多线程的内存图解

多线程执行时，到底在内存中是如何运行的呢？

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。

![](https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/12899166-e805204e7d00f1d6.png)

::: tip
下篇文章将详细介绍多线程以及如何创建多线程。
:::